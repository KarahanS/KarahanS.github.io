<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Scoring Rules | Karahan Sarıtaş</title> <meta name="author" content="Karahan Sarıtaş"/> <meta name="description" content="<A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/ship.png"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://karahans.github.io/blog/20240201"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://karahans.github.io/"><span class="font-weight-bold">Karahan</span> Sarıtaş</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/resume/">resume</a> </li> <li class="nav-item "> <a class="nav-link" href="/archive/">archive</a> </li> <div class="toggle-container"> <a id="light-toggle"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </a> </div> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Scoring Rules</h1> <p class="post-description"></p> </header> <article> <h3 id="table-of-contents">Table of Contents</h3> <ul> <li><a href="#1-introduction">Introduction</a></li> <li> <a href="#2-definitions">Definitions</a> <ul> <li><a href="#21-scoring-rule">Scoring Rule</a></li> <li><a href="#22-proper-scoring-rule">Proper Scoring Rule</a></li> <li><a href="#23-strictly-proper-scoring-rule">Strictly Proper Scoring Rule</a></li> </ul> </li> <li> <a href="#3-scoring-rules">Scoring Rules</a> <ul> <li><a href="#31-log-probability">Log Probability</a></li> <li><a href="#32-brier-score">Brier Score</a></li> </ul> </li> <li> <a href="#4-proofs">Proofs</a> <ul> <li><a href="#41-theorem-log-probability-scoring-rule">Theorem (Log Probability Scoring Rule)</a></li> <li><a href="#42-theorem-brier-scoring-rule">Theorem (Brier Scoring Rule)</a></li> </ul> </li> <li> <a href="#5-application-predictive-certainty">Application: Predictive Certainty</a> <ul> <li><a href="#51-max-prob-confidence">Max-Prob Confidence</a></li> <li><a href="#52-bce-loss">BCE Loss</a></li> </ul> </li> <li><a href="#conclusion">Conclusion</a></li> </ul> <h2 id="1-introduction">1) Introduction</h2> <p>Scoring rules are used to evaluate the performance of probabilistic forecasts. Roughly, a scoring rule is a function that maps a forecast and an observation to a real number, which is interpreted as a measure of the quality of the forecast. For a rational agent who wants to maximize the expected score, the best forecast is the one that is most likely to be the true observation. In this post, we will discuss a couple of definitions related to scoring rules . Then we will examine some of the commonly used proper scoring rules in the literature. At the end we’ll briefly discuss the relationship between scoring rules and predictive certainty.</p> <h2 id="2-definitions">2) Definitions</h2> <h5 id="21-scoring-rule">2.1) Scoring Rule</h5> <p>A scoring rule is any extended real-valued function \(\mathbf{S}: \mathcal{Q} \times \Omega \rightarrow \mathbb {R}\) where \(\mathcal{Q}\) is a family of probability distributions over the space \(\Omega\), such that \(\mathbf{S}(Q, \cdot)\) is \(\mathcal{Q}\)-quasi-integrable* for all \(Q \in \mathcal{Q}\). Output of the function \(\mathbf{S}(Q, y)\) represents the loss or penalty when the forecast \(Q \in \mathcal{Q}\) is issued and the observation \(y \in \Omega\) is realized.</p> <p>*In our definition, we use the term “quasi-integrable” to mean that the function is integrable with respect to the measure induced by the probability distribution. This is just a technical condition that ensures the existence of the expected score. So, nothing to worry about here.</p> <h5 id="22-proper-scoring-rule">2.2) Proper Scoring Rule</h5> <p>A scoring rule \(\mathbf{S}\) is called a <strong>proper scoring rule</strong>, if and only if</p> \[\label{eq:psr} \max_{Q \in \mathcal{Q}} \mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] = \mathbb{E}_{Y \sim P}[\mathbf{S}(P, Y)] \; .\] <p>In other words, score function \(\mathbf{S}\) is a proper scoring rule, if it is maximized when the forecaster gives exactly the ground truth distribution \(P(Y)\) as its probabilistic forecast \(Q \in \mathcal{Q}\).</p> <h5 id="23-strictly-proper-scoring-rule">2.3) Strictly Proper Scoring Rule</h5> <p>A scoring rule \(\mathbf{S}\) is called a <strong>strictly proper scoring rule</strong>, if and only if</p> <ul> <li> <p>\(\mathbf{S}\) is a proper scoring rule, and</p> </li> <li> <p>\(\operatorname*{arg\,max}_{Q \in \mathcal{Q}} \; \mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] = P\) is the unique maximizer of \(\mathbf{S}\) in \(Q\).</p> </li> </ul> <p>In other words, a strictly proper scoring rule is maximized only when the the forecaster gives exactly the ground truth distribution \(P(Y)\) as its probabilistic forecast \(Q \in \mathcal{Q}\).</p> <p>So, there is a slight difference between <em>proper scoring rules</em> and <em>strictly proper scoring rules</em>. In an ideal scenario, we want our scoring rule to be strictly proper so that it awards the maximum reward only to the forecaster who gives the true distribution as its forecast.</p> <h2 id="3-scoring-rules">3) Scoring Rules</h2> <h5 id="31-log-probability">3.1) Log Probability</h5> <p>A log (probability) scoring rule \(S(q, y)\) is as a scoring rule that measures the quality of a probabilistic forecast in decision theory. Formally, it can be defined in discrete or continuous form as follows:</p> <p>1) Log scoring rule for binary classification:</p> \[S(q, y) = \left\{ \begin{array}{rl} \log q \; , &amp; \text{if} \; y = 1 \\ \log(1-q) \; , &amp; \text{if} \; y = 0 \end{array} \right.\] <p>which can be expressed as</p> \[\label{eq:binary-lpsr} S(q, y) = y \log q + (1-y) \log (1-q)\] <p>Note that the expressions given above have slightly different domains. For the first equation, the domain is \(D_1 = ([0,1) \times \left\lbrace 0 \right\rbrace) \cup ((0, 1] \times \left\lbrace 1 \right\rbrace)\), while for the second equation, the domain is \(D_2 = (0,1) \times \left\lbrace 0,1 \right\rbrace\).</p> <p>2) Log scoring rule for multiclass classification:</p> \[\label{eq:multiclass-lpsr} S(q, y) = \sum_k y_k \log q_k(x) = \log q_{y^*}(x)\] <p>where \(y^*\) is the true class and \(q\) is the predicted probability distribution over the classes. We have \(y_k = 1\), if the true class is \(k\) and \(y_k = 0\) otherwise.</p> <p>3) Log scoring rule for regression (continuous case):</p> \[\label{eq:regression-lpsr} S(q, y) = \log q(y)\] <p>where \(q\) is the predicted probability distribution over the continuous space and \(y\) is the true value.</p> <h5 id="32-brier-score">3.2) Brier Score</h5> <p>1) Brier score for binary classification:</p> \[S(q, y) = -(q - y)^2\] <p>\(q\) represents the predicted probability of the positive class (\(Y = 1\)) and \(y\) is the true class label. Since we want the output of the scoring rule to be maximized when the predicted probability is close to the true class label, we use the negative of the squared difference between the predicted probability and the true class label.</p> <p>2) Brier score for multiclass classification:</p> \[S(q, y) = -\sum_k (q_k - y_k)^2 = -(q_{y^*} - 1)^2 -\sum_{k \neq y^*} q_k^2\] <p>where \(q_k\) is the predicted probability of the class \(y^*\) is the true class label. Similar to the log probability score, we have \(y_k = 1\), if the true class is \(k\) and \(y_k = 0\) otherwise.</p> <p>Although there is no direct version of Brier score for regression, we can use the squared error loss as a scoring rule for regression problems.</p> <h2 id="4-proofs">4) Proofs</h2> <p>Having defined the scoring rules and given examples for them, we can now prove that those scoring rules are strictly proper. We will start with the log probability scoring rule.</p> <h5 id="41-theorem-log-probability-scoring-rule">4.1) Theorem (Log Probability Scoring Rule)</h5> <p><strong>Theorem:</strong> The log (probability) scoring rule is a strictly proper scoring rule.</p> <p><strong>Proof:</strong> We will show that all versions of the log probability scoring rule (binary/multiclass/regression) are strictly proper scoring rules.</p> <p>1) Binary log probability scoring rule:</p> \[\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] = P(Y = 1) \log q + P(Y = 0) \log (1 - q)\] <p>Let \(p\) be the true probability of the event \(Y = 1\). Then, the expected score is:</p> \[\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] = p \log q + (1 - p) \log (1 - q)\] <p>To find the maxima, take the derivative with respect to \(q\) and set it to zero:</p> \[\begin{split} \frac{\partial}{\partial q}\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] &amp;= \frac{p}{q} - \frac{1-p}{1 - q} \\ 0 &amp;= \frac{p - pq - q + pq}{q (1-q)} \\ 0 &amp;= \frac{p - q}{q (1-q)} \\ \Rightarrow p - q &amp;= 0 \\ \Rightarrow p &amp;= q \end{split}\] <p>Now, we need to check the second derivative to see, if it is a maximum for the properness condition and if it is the only maximizer for the strictness condition:</p> \[\begin{split} \frac{\partial^2}{\partial q^2}\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] &amp;= -\frac{p}{q^2} - \frac{1-p}{(1 - q)^2} \\ &amp;= - \left( \underbrace{\frac{p}{q^2}}_\textrm{&gt; 0} + \underbrace{\frac{1-p}{(1 - q)^2}}_\textrm{&gt; 0} \right) &lt; 0 \end{split}\] <p>Except for the cases \(q=0\) and \(q=1\), the second derivative is always negative, which means that the function is concave and the maximum is unique. For \(q = 1\), maximum is achieved only if \(p = 1\), and similarly for \(q = 0\), maximum is achieved only if \(p = 0\). Therefore, \(p = q\) is the only maximizer and the log probability scoring rule for binary classification is strictly proper.</p> <p>2a) Multiclass log probability scoring rule (Proof #1):</p> \[S(q, y) = \sum_k^K y_k \log q_k(x)\] <p>Let \(p_k\) be the true probability of the event \(Y = k\). Since \(q_k\) is the predicted probability for class \(k\), we know that \(\sum_i q_i = 1\). Then, the expected score is:</p> \[\begin{split} \mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] &amp;= \sum_k P(Y = k|x) \log(q_k(x)) \\ &amp;= p_1 \log(q_1(x)) + p_2\log(q_2(x)) + ... + p_K \log(q_K(x)) \\ &amp;= p_1 \log(q_1(x)) + p_2\log(q_2(x)) + ... + p_K \log(1 - \sum_{i \neq K} q_i(x)) \end{split}\] <p>Taking the derivative with respect to \(q_j\) and setting it to zero:</p> \[\begin{split} \frac{\partial}{\partial q_j}\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] &amp;= \frac{p_j}{q_j} -\frac{p_K}{1- \sum_{i \neq K} q_i(x)} \\ 0 &amp;= \frac{p_j}{q_j} - \frac{p_K}{q_K} \\ \Rightarrow \frac{p_j}{q_j} &amp;= \frac{p_K}{q_K} \end{split}\] <p>This equality holds for any \(j\):</p> \[\frac{p_1}{q_1} = \frac{p_2}{q_2} = ... = \frac{p_K}{q_K} = \lambda\] <p>Each \(q_i\) can be represented as a constant multiple of \(p_i\) as follows: \(q_i = \lambda \ p_i\)</p> \[\begin{split} \sum_i q_i &amp;= 1 \\ \sum_i \lambda \ p_i &amp;= 1 \\ \lambda \sum_i p_i &amp;= 1 \\ \lambda = 1 \end{split}\] <p>Since \(\lambda = 1\), we have \(p_i = q_i\) for all \(i\). Now, we need to check the second derivative to see, if it is a maximum for the properness condition and if it is the only maximizer for the strictness condition:</p> \[\begin{split} \frac{\partial^2}{\partial q_j^2}\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] &amp;= -\frac{p_j}{q_j^2} - \frac{p_K}{(1- \sum_{i \neq K} q_i(x))^2} \\ &amp;= - \left( \underbrace{\frac{p_j}{q_j^2}}_\textrm{&gt; 0} + \underbrace{\frac{p_K}{(1- \sum_{i \neq K} q_i(x))^2}}_\textrm{&gt; 0} \right) &lt; 0 \end{split}\] <p>Except for the cases \(q_j=0\) and \(q_j=1\), the second derivative is always negative, which means that the function is concave and the maximum is unique. For \(q_j = 1\), maximum is achieved only if \(p_j = 1\), and similarly for \(q_j = 0\) maximum is achieved only if \(p_j = 0\). Therefore, \(p_j = q_j\) is the only maximizer and the log probability scoring rule for multiclass classification is strictly proper.</p> <p>2b) Multiclass log probability scoring rule (Proof #2):</p> <p>Alternatively, we can solve the optimization problem with Lagrange multipliers. The Lagrangian is:</p> \[\mathcal{L}(q, \lambda) = \sum_k P(Y = k|x) \log(q_k(x)) + \lambda \left(1 - \sum_k q_k(x)\right)\] <p>Taking the derivative with respect to \(q_j\) and setting it to zero:</p> \[\begin{split} \frac{\partial}{\partial q_j}\mathcal{L}(q, \lambda) &amp;= \frac{p_j}{q_j} - \lambda \\ 0 &amp;= \frac{p_j}{q_j} - \lambda \\ \Rightarrow \frac{p_j}{q_j} &amp;= \lambda \end{split}\] <p>The rest of the proof follows as in the first proof.</p> <p>3) Continuous log probability scoring rule:</p> \[S(q, y) = \log q(y)\] <p>Let \(p(y)\) be the true probability density function of the event \(Y = y\). Then, the expected score is:</p> \[\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] = \int p(y) \log q(y) dy\] <p>Let \(X = \frac{q(y)}{p(y)}\) and \(\phi = \log(\cdot)\) (a concave function). By Jensen’s inequality, we know that \(f(\mathbb{E}[X]) \leq \mathbb{E}[f(X)]\), if \(f\) is concave. Therefore, we have:</p> \[\begin{split} \int p(y) \log \frac{q(y)}{p(y)} dy &amp;\leq \log \int p(y)\frac{q(y)}{p(y)} dy \\ \int p(y) \log \frac{q(y)}{p(y)} dy &amp;\leq \log \int q(y) dy \\ \int p(y) \log \frac{q(y)}{p(y)} dy &amp;\leq \log(1) \\ \int p(y) \log \frac{q(y)}{p(y)} dy &amp;\leq 0 \end{split}\] <p>The same result can be obtained by using the Kullback-Leibler divergence. The Kullback-Leibler divergence is always non-negative, therefore \(\text{E} - \text{CE} = \text{KL} \geq 0\). The resulting expression is \(-\text{KL}\), which is always non-positive. It is maximized only when \(q(y) = p(y)\) which means that the log probability scoring rule for continuous classification is strictly proper.</p> <p>An alternative argument for uniqueness of the maximum point can be proposed as follows: \(\int p(y) \log \frac{q(y)}{p(y)} dy\) can be equal to \(0\) in two cases: Either \(\frac{q(y)}{p(y)}\) is equal to \(1\) for each value or the expression \(\log ( \frac{q(y)}{p(y)})\) takes positive and negative values summing up to \(0\) at the end. The second case cannot occur, because it means that there exists a \(y_0\) such that \(q(y_0) &gt; p(y_0)\), implying that Jensen’s inequality is violated. Therefore, the maximum is achieved, if and only if \(q = p\).</p> <h5 id="42-theorem-brier-scoring-rule">4.2) Theorem (Brier Scoring Rule)</h5> <p><strong>Theorem:</strong> The Brier scoring rule is a strictly proper scoring rule.</p> <p><strong>Proof:</strong> We will show that the Brier scoring rule is strictly proper for both binary and multiclass classification.</p> <p>1) Binary Brier Scoring rule:</p> \[\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] = - P(Y = 1) (q - 1)^2 + P(Y = 0) -q^2\] <p>Let \(p\) be the true probability of the event \(Y = 1\). Then, the expected score is:</p> \[\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] = - p (q - 1)^2 - (1 - p) q^2\] <p>To find the maxima, take the derivative with respect to \(q\) and set it to zero:</p> \[\begin{split} \frac{\partial}{\partial q}\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] &amp;= -2p(q - 1) - 2(1 - p)q \\ &amp;= -2pq + 2p - 2q + 2pq \\ &amp;= 2p - 2q \\ 0 &amp;= 2p - 2q \\ \Rightarrow p &amp;= q \end{split}\] <p>We need to check the second derivative to see, if it is a maximum for the properness condition and if it is the only maximizer for the strictness condition:</p> \[\begin{split} \frac{\partial^2}{\partial q^2}\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] &amp;= -2 &lt; 0 \\ \end{split}\] <p>Second derivative is always negative, which means that the function is concave and the maximum is unique. Therefore, \(p = q\) is the only maximizer and the Brier scoring rule for binary classification is strictly proper.</p> <p>2) Multiclass Brier Scoring rule:</p> \[\begin{split} \mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] &amp;= \sum_k P(Y = k) \bigg[ -\sum_i (q_i - y_i)^2 \bigg]\\ &amp;= \sum_k P(Y = k) \bigg[ -(q_{k} - 1)^2 -\sum_{i \neq k} q_i^2 \bigg] \\ &amp;= \sum_k P(Y = k) \bigg[ -(q_{k} - 1)^2 + q_k^2 -\sum_{i} q_i^2 \bigg] \\ &amp;= \sum_k P(Y = k) \bigg[ -q_{k}^2 - 1 + 2q_k + q_k^2 -\sum_{i} q_i^2 \bigg] \\ &amp;= \sum_k P(Y = k) \bigg[ 2q_k - 1 -\sum_{i} q_i^2 \bigg] \\ &amp;= \sum_k P(Y = k)(2q_k - 1) - \sum_k P(Y = k) \bigg(\sum_i q_i^2\bigg) \\ &amp;= \sum_k P(Y = k)(2q_k - 1) - \sum_i q_i^2 \bigg(\underbrace{\sum_k P(Y = k)}_\textrm{1}\bigg) \\ &amp;= \sum_k P(Y = k)(2q_k - 1) - \sum_i q_i^2 \\ &amp;= \sum_k P(Y = k)(2q_k - 1) - q_k^2 \end{split}\] <p>Similar to what we did for log probability, this expression can be expressed as follows (replacing \(q_K\) with \(1 - \sum_{i \neq K} q_i\)):</p> \[\begin{split} \mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] &amp;= p_1(2q_1 - 1) - q_1^2 + p_2(2q_2 - 1) - q_2^2 + ... + p_K(2q_K - 1) - q_K^2 \\ &amp;= p_1(2q_1 - 1) -q_1^2 + p_2(2q_2 - 1) -q_2^2 + ... + p_K(1 - 2\sum_{i \neq K} q_i) - (1 - \sum_{i \neq K} q_i)^2\\ \end{split}\] <p>Taking the derivative with respect to \(q_j\) and setting it to zero:</p> \[\begin{split} \frac{\partial}{\partial q_j}\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] &amp;= 2p_j - 2q_j - 2p_K + 2 (1 - \sum_{i \neq K} q_i) \\ &amp;= 2p_j - 2q_j - 2p_K + 2 q_K \\ &amp;= (p_j - q_j) + (q_K - p_K) \\ (p_j - q_j) &amp;= (p_K - q_K) \\ \end{split}\] <p>For all derivaties, the following equality holds:</p> \[p_1 - q_1 = p_2 - q_2 = ... = p_K - q_K = \lambda\] <p>We know that \(\sum_i q_i = 1\) and \(\sum_i p_i = 1\), therefore:</p> \[\begin{split} \sum_i p_i - q_i &amp;= K \cdot \lambda = 0 \\ \Rightarrow \lambda &amp;= 0\\ \Rightarrow p_i &amp;= q_i \end{split}\] <p>Now, we need to check the second derivative to see, if it is a maximum for the properness condition and if it is the only maximizer for the strictness condition:</p> \[\begin{split} \frac{\partial^2}{\partial q_j^2}\mathbb{E}_{Y \sim P}[\mathbf{S}(Q, Y)] &amp;= - 2 - 2 &lt; 0 \\ \end{split}\] <p>The second derivative is always negative, which means that the function is concave and the maximum is unique. Therefore, \(p = q\) is the only maximizer and the Brier scoring rule for multiclass classification is strictly proper.</p> <h2 id="5-application-predictive-certainty">5) Application: Predictive Certainty</h2> <p>Ok, so far so good. We have seen that there is a concept called scoring rule, and we have seen that log probability and Brier scoring rules are strictly proper. But, why do we care about scoring rules? There are lots of different application areas for scoring rules, but among them, one of the most important ones is predictive certainty. Predictive certainty is the measure of how certain the model is about its predictions. In other words, it is the measure of how much the model trusts its predictions. Scoring rules can be used to measure the predictive certainty of a model.</p> <h5 id="51-max-prob-confidence">5.1) Max-Prob Confidence</h5> <p>How can one measure the predictive certainty? Well, let’s say we are dealing with a binary classification problem. Our predicted output can take values between 0 and 1. Here, intuitively we say that our model is certain about its prediction (as positive) when it is very close to 1, and again it is certain about its prediction (as negative) when it is very close to 0. Therefore, we can use the predicted probability as a measure of the predictive certainty. In other words, we can use the predicted probability as a measure of how much the model trusts its predictions. This is called <strong>max-prob confidence</strong>.</p> <p>Let’s define a random variable \(L\) which represents the correctness of our prediction.</p> \[\begin{equation*} L = \begin{cases} 1 &amp;\text{if prediction is correct}\\ 0 &amp;\text{otherwise} \end{cases} \end{equation*}\] <p>Then \(P(L = 1)\) corresponds to the probability that our prediction is correct. In the deployment environment, we don’t really know if our prediction is wrong or not (otherwise we wouldn’t need to make a prediction at all). Our aim is to get the most reliable “estimate” for \(P(L=1)\) so that we really know how confident our model is about its predictions. For a real life scenario, think about a doctor who is trying to diagnose a patient. Diagnosing a patient who is not really sick (false positive), may not be a huge problem (except the stress and the cost). But, <strong>not</strong> diagnosing a patient who is really sick (false negative), is a serious problem. Therefore, the doctor should be very confident about his/her diagnosis. An ML algorithm tailored for analyzing medical documents might conclude that the patient is in good health. If the doctor is provided with the confidence level of the algorithm, he/she can decide whether to trust the algorithm or not. If the confidence level is high, the doctor may trust the algorithm. If the confidence level is low, the doctor may attempt to run some additional tests to make sure that the patient is not sick.</p> <p>We want to reward the “reporter” of the confidence level if the reported confidence is close to the real confidence \(P(L=1)\). Does it sound familiar? So, here is the part where scoring rules come into play. We can use a proper scoring rule to <em>encourate</em> the reporter to provide confidence levels as close as possible to the real (ground-truth) confidence level \(P(L=1)\).</p> <h5 id="52-bce-loss">5.2) BCE Loss</h5> <p>Here’s the good news! Majority of the traditional loss functions we employ during the training of our models are already proper scoring rules for predicting the confidence level using max-prob confidence. In a sense, they do not only aim to achieve highest accuracy, but also the truthfulness of the max-prob confidence. So, if an algorithm predicts 0.9 for its prediction, we can be sure that this prediction is more likely to be true. Here, it’s important not to conflate the concepts of “accuracy” and “confidence.” Our algorithm might demonstrate high accuracy but lack confidence in its predictions, perhaps consistently outputting probabilities around 0.55 for positive cases and 0.45 for negative cases. Conversely, it could exhibit high confidence despite lower accuracy; for instance, consistently outputting around 0.9 for negative samples, despite this leading to incorrect predictions. We do not want our model to be underconfident or overconfident.</p> <p>Now, let’s show that one of the most commonly used loss functions, the negative of Binary Cross-Entropy (BCE) loss, is also a proper scoring rule for max-prob confidence. Since loss is usually minimized and score is maximized, we use the negative of BCE loss as a scoring rule.</p> <blockquote> <p>Careful! It is not that using BCE loss aims to maximize the reported confidence level. Both overconfidence and underconfidence are undesired calibration errors. The aim is to <strong>minimize the loss</strong> and <strong>maximize the score</strong> (latter means encouraging the reporter to provide confidence levels as close as possible to the real confidence level \(P(L=1)\)).</p> </blockquote> <p>Let’s start from the beginning. Now, we want to create a game where there is a reporter of the confidence and the ground truth confidence level \(P(L=1)\). We would like to make sure that the reported confidence level is as close as possible to the real confidence level. We have to design a scoring rule to reward the reporter. We know that log probability score is a strictly proper scoring rule, therefore it is only maximized when the reporter gives the true distribution as its probabilistic forecast. Let \(c(x) = \max(f(x), 1 - f(x))\) and remember the binary log probability scoring rule:</p> \[\begin{equation*} S(c, L) = \begin{cases} \log(c(x)) &amp;\text{if $L$ = 1}\\ \log(1 - c(x)) &amp;\text{if $L$ = 0} \end{cases} \end{equation*}\] <p>We know that \(c = p(L)\) is the unique maximizer of this scoring function. Let’s evaluate the cases:</p> <ol> <li>\(Y = 0\) and \(\hat{Y} = 0\): Our prediction is correct, scoring function outputs \(\log(1-f(x))\)</li> <li>\(Y = 0\) and \(\hat{Y} = 1\): Our prediction is wrong, scoring function outputs \(\log(1 - f(x))\)</li> <li>\(Y = 1\) and \(\hat{Y} = 0\): Our prediction is wrong, scoring function outputs \(\log(f(x))\)</li> <li>\(Y = 1\) and \(\hat{Y} = 1\): Our prediction is correct, scoring function outputs \(\log(f(x))\)</li> </ol> <p>Let’s re-formulate the scoring function:</p> \[S(f, Y) = \begin{cases} \log (f(x)) \;\;\;\;\;\;\;\;\;\;\;\;\text{if}\; Y = 1 \\ \log(1 -f(x)) \;\;\;\;\;\ \text{if} \; Y = 0 \end{cases}\] <p>where \(f\) is the predicted probability and \(x\) is the input data.</p> <p>This is negative BCE! As claimed, it turns out that minimization of binary cross-entropy loss (or maximization of negative BCE) encourages not only the correctness of classification \(f(x)\), but also the truthfulness of the max-prob confidence \(c(x) = \max (f(x), 1 - f(x))\).</p> <h2 id="conclusion">Conclusion</h2> <p>In this post, we have discussed the concept of scoring rules and their importance in evaluating the performance of probabilistic forecasts. We have defined scoring rules and given examples for proper scoring rules. We have shown that log probability and Brier scoring rules are strictly proper. We have also discussed the relationship between scoring rules and predictive certainty. We have shown that the negative of Binary Cross-Entropy (BCE) loss is a proper scoring rule for max-prob confidence. As a result, we have seen that the minimization of BCE loss encourages not only the correctness of classification, but also the truthfulness of the max-prob confidence. Negative Log-Likelihood (NLL), which is the same as Cross Entropy Loss (they have slightly different input expectations in PyTorch, so be careful), is also a proper scoring rule for max-prob confidence. It is a popular metric for evaluating predictive uncertainty as well (<a href="https://arxiv.org/pdf/1612.01474.pdf" target="_blank" rel="noopener noreferrer">Simple and Scalable Predictive Uncertainty Estimation using Deep Ensembles</a>).</p> <p><strong>References:</strong> Bálint Mucsányi, Michael Kirchhof, Elisa Nguyen, Alexander Rubinstein, Seong Joon Oh (2023): “Proper/Strictly Proper Scoring Rule”; in: Trustworthy Machine Learning; URL: https://trustworthyml.io/; DOI: 10.48550/arXiv.2310.08215.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Karahan Sarıtaş. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script src="/assets/js/zoom.js"></script> <script src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> </body> </html>