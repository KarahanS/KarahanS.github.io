<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Bayesian Machine Learning in Practice | Karahan Sarıtaş</title> <meta name="author" content="Karahan Sarıtaş"/> <meta name="description" content="<A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/ship.png"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://karahans.github.io/blog/20240303"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://karahans.github.io/"><span class="font-weight-bold">Karahan</span> Sarıtaş</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/resume/">resume</a> </li> <li class="nav-item "> <a class="nav-link" href="/archive/">archive</a> </li> <div class="toggle-container"> <a id="light-toggle"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </a> </div> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Bayesian Machine Learning in Practice</h1> <p class="post-description"></p> </header> <article> <h3 id="table-of-contents">Table of Contents</h3> <ul> <li><a href="#bayesian-approach">Bayesian Approach</a></li> <li><a href="#bayesian-ml-approach-1-ensemble">Bayesian ML Approach #1: Ensemble</a></li> <li><a href="#bayesian-ml-approach-2-training-infinite-number-of-models-bayes-by-backprop">Bayesian ML Approach #2: Training Infinite Number of Models (Bayes by Backprop)</a></li> <li><a href="#bayesian-ml-approach-3-dropout">Bayesian ML Approach #3: Dropout</a></li> <li><a href="#bayesian-ml-approach-4-training-a-curve-of-an-infinite-number-of-models">Bayesian ML Approach #4: Training a Curve of an Infinite Number of Models</a></li> <li><a href="#bayesian-ml-approach-5-stochastic-weight-averaging-swag">Bayesian ML Approach #5: Stochastic Weight Averaging (SWAG)</a></li> </ul> <h2 id="bayesian-approach">Bayesian Approach</h2> <p>What is the difference between <em>Deterministic ML</em> and <em>Bayesian ML</em>?</p> <ul> <li> <p>Deterministic ML first optimizes a single model over the training set, \(\theta^*(\mathcal{D})\) where \(\mathcal{D}\) is the training data (a collection of \((Y_i, X_i)\)). Then for a test sample, it predicts the label as follows:</p> \[P(y \mid x, \mathcal{D}) = P(y \mid x, \theta^*(\mathcal{D}))\] </li> <li>We use only this single model to produce the output for input of interest. From the Bayesian perspective, this is equivalent to having a <a href="https://en.wikipedia.org/wiki/Dirac_delta_function" target="_blank" rel="noopener noreferrer">Dirac</a> posterior.</li> <li>Epistemic uncertainty arises when the model encounters with a test sample that lies in the underexplored region (region that is not covered by the training dataset). In that case, we might have multiple plausible models. Since we only consider a single one in deterministic ML, we cannot represent epistemic uncertainty using deterministic ML.</li> <li>Different set of parameters maximizes the probability, meaning that there are more than one optimum models for the task - at least based on the given training set (epistemic uncertainty).</li> </ul> <p>Bayesian ML finds a distribution of models: \(p(\theta \mid \mathcal{D})\)</p> <p>Then the prediction for a specific test sample is made through <strong>Bayesian Model Averaging</strong> (BMA)/marginalization:</p> \[P(y | x, \mathcal{D}) = \int{P(y | x, \theta) \; P(\theta | \mathcal{D}) \; d\theta} = \mathbb{E}_{\theta \sim P(\theta|\mathcal{D})} P(y |x, \theta)\] <p>The idea can be simplified as follows: Let’s say there are \(3\) different models (weights) with \(0.4, 0.4\), and \(0.2\) probabilities. Models output predicted probability as \(0.3, 0.25, 0.4\) respectively. Then the expected predicted probability becomes: \(0.4 \times 0.3 + 0.4 \times 0.25 + 0.2 \times 0.4\) = \(0.3\).</p> <hr> <p>Recipe:</p> <ol> <li>Find a clever way to calculate (approximate) posterior distribution \(p(\theta \mid \mathcal{D})\). There are lots of ways listed below.</li> <li> <p>Using the posterior, get the prediction using <strong>Bayesian Model Averaging.</strong> Basically, we are calculating the expected value of the prediction based on the distribution \(\theta \sim p(\theta \mid \mathcal{D})\). Here we can use <strong>Monte Carlo Simulation</strong> to calculate the expected value easily.</p> \[P(y | x, \mathcal{D}) = \int{P(y | x, \theta) \; P(\theta | \mathcal{D}) \; d\theta} = \mathbb{E}_{\theta \sim P(\theta|\mathcal{D})} P(y |x, \theta)\] </li> </ol> <hr> <p>Using Bayes’ Theorem and marginalization, we know that \(p(a)=\int p(a,b)db\). Using this equality, we can derive the following:</p> \[\begin{split} P(y | x, \mathcal{D}) &amp;= \int P(y, \theta | x, \mathcal{D}) d\theta \\ &amp;= \int P(y | \theta , x, \mathcal{D}) P(\theta | x, \mathcal{D}) d\theta \\ &amp;= \int P(y | \theta , x) P(\theta | \mathcal{D}) d\theta \\ &amp;= \mathbb{E}_{\theta \sim P(\theta|\mathcal{D})} P(y |x, \theta) \end{split}\] <center> <figure> <picture> <img src="/assets/posts/post1/bayesian-3.png" class="img-fluid rounded z-depth-1" width="400" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">Dependencies between test sample \(\{x, y\}\), training data \(\mathcal{D}\) and the model parameters \(\theta\) can be visualized as above.</figcaption> </figure> </center> <p>Simple observations for the network:</p> <ul> <li> <p>Test label \(y\) is independent of the training data given the parameters \(w\). That is, \(p(y, \mathcal{D} \mid w) = p(y \mid w) p(\mathcal{D} \mid w)\)</p> </li> <li> <p>\(w\) is independent of the test input \(x\). But be careful! It becomes dependent on it when the \(y\) is given. You can think of it as two independent dice throws - where \(y\) represents the event = sum of the throws is equal to 4. Without \(y\), we know that the result of the first throw is independent of the result of the second throw. But if we know that \(y\) is true or false, then the result of the first throw, then the result of the second throw becomes dependent on it.</p> </li> </ul> <h2 id="bayesian-ml-approach-1-ensemble">Bayesian ML Approach #1: Ensemble</h2> <p>So, we can utilize Bayesian ML to formulate epistemic uncertainty. Great, but how can we produce the probability distribution \(P(\theta \mid D)\)? One way of doing it is using ensemble approach - where we train a model \(M\) times with different random seeds. We can directly use the original training set or sample with replacement from it for each training. Here, we train several deterministic models. Therefore at the end, our distribution \(P(\theta \mid D)\) simply becomes the sum of Dirac measures*.</p> <p>Dirac measure, given a measurable space \((\Omega, \mathcal{B})\) and \(w \in \Omega\), is a function \(\delta_w: \mathcal{B} \rightarrow \Omega\), defined as follows:</p> \[\delta_w(A) = \begin{cases} 1, \; \text{if $\omega \in A$} \\ 0, \; \text{if $\omega \notin A$} \end{cases}\] <p>There is also the Dirac delta function (not formally a function)</p> \[\delta(x)= \begin{cases} \infty, \; \text{if $x = 0$} \\ 0, \; \text{if $x \neq 0$} \end{cases}\] <p>The function \(δ(x)\) has the value zero everywhere except at \(x = 0\), where its value is infinitely large and is such that its total integral is \(1\).</p> <p><a href="https://en.wikipedia.org/w/index.php?title=Probability_distribution#Dirac_delta_representation" target="_blank" rel="noopener noreferrer">Dirac function is commonly used to represent discrete probability distributions in a continuous way.</a></p> <p>As a probability distribution, integral of the Dirac function over the whole domain gets equal to \(1\).</p> \[\int_{-\infty}^\infty \delta(x) dx = 1\] <p>One final property that is extremely important is the following:</p> \[\int_{-\infty}^{\infty} f(x) \delta(x - c) \,dx = f(c)\] <p>There is a proof for this property <a href="https://math.stackexchange.com/questions/73010/proof-of-dirac-deltas-sifting-property" target="_blank" rel="noopener noreferrer">here</a>.</p> <p>When we train ensemble of \(M\) models, we basically get the sum of Dirac measures as our probability distribution of the random variable \(\theta\). Each Dirac measure is given as \(\delta(\theta - \theta_m)\).</p> <p>When we train ensemble of \(M\) models, we basically get the sum of Dirac measures as our probability distribution of the random variable \(\theta\). Each Dirac measure is given as \(\delta(\theta - \theta_m)\).</p> \[P(\theta|D) = \frac{1}{M} \sum_m \delta(\theta - \theta_m)\] <ul> <li> <p>“Sum of diracs” should be a probability distribution, therefore its integral over real numbers must be equal to 1.</p> \[\begin{split} &amp;\int_{-\infty}^\infty \frac{1}{M} \sum_m \delta(\theta - \theta_m)d\theta \\ &amp;= \frac{1}{M} \sum_m \int_{-\infty}^\infty \delta(\theta - \theta_m)d\theta \\&amp;= \frac{1}{M} \sum_m \int_{-\infty}^\infty \delta(y)dy \\&amp;= \frac{1}{M} \sum_m 1 \\&amp;= \frac{1}{M} M \\&amp;= 1 \end{split}\] <p>Now, we can insert our posterior to the Bayesian Model Averaging:</p> \[\begin{split} P(y \mid x, \mathcal{D}) &amp;= \int{P(y \mid x, \theta) \; P(\theta \mid \mathcal{D}) \; d\theta} \\ \;\;\; \;\;\; \;\;\; \;\;\; \;\;\;\; &amp;= \int{P(y \mid x, \theta) \; \frac{1}{M} \sum_m \delta(\theta - \theta_m) \; d\theta} \\ \;\;\; \;\;\; \;\;\; \;\;\; \;\;\;\; &amp;= \frac{1}{M} \sum_m \int{P(y \mid x, \theta) \delta(\theta - \theta_m) \; d\theta} \\ \;\;\; \;\;\; \;\;\; \;\;\; \;\;\;\; &amp;= \frac{1}{M} \sum_m P(y \mid x, \theta_m) \end{split}\] <p>So, as a result, we can get the prediction by taking the average of the resulting predictions from different models.</p> </li> <li>Pros <ul> <li>Conceptually simple - run training algorithm \(M\) times.</li> <li>Applicable to a wide range of models - from Linear Regression to LLMs</li> <li>Embarrassingly parallel - easy to parallelize.</li> </ul> </li> <li>Cons <ul> <li>Perhaps not realizing the full potential of Bayesian ML (only finite #models).</li> <li>Space &amp; time complexities scale linearly with \(M\) (#models).</li> </ul> </li> </ul> <h2 id="bayesian-ml-approach-2-training-infinite-number-of-models-bayes-by-backprop">Bayesian ML Approach #2: Training Infinite Number of Models (Bayes by Backprop)</h2> <p>Of course, it is not practically possible to train “infinite” number of models. But think about this: you can represent a probability distribution of infinite number of random variables with finite number of parameters (mean and variance). This is what we’ll try to do here. This approach called <em>Bayes by Backprop</em> is first introduced in the paper <a href="https://arxiv.org/abs/1505.05424" target="_blank" rel="noopener noreferrer">Weight Uncertainty in Neural Networks</a>.</p> <p>So, we can approximate \(P(\theta \mid \mathcal{D})\) simply by a Gaussian distribution:</p> <p>\(P(\theta \mid \mathcal{D}) \sim \mathcal{N}(\theta \mid \mu^*(\mathcal{D}), \Sigma^*(\mathcal{D}))\) (Here since \(D\) consists of all inputs, it is multivariate Gaussian)</p> <p>However, we don’t really know if the posterior follows a Gaussian distribution. We can try to find the closest Gaussian distribution to the actual distribution of the posterior. We would like to minimize the distance between the two distributions. Which metric quantifies how much one probability distribution differs from another probability distribution? KL-Divergence!</p> \[\text{min}_{\mu, \Sigma} d(\mathcal{N}(\theta | \mu(\mathcal{D}), \Sigma(\mathcal{D})), p(\theta | \mathcal{D}))\] <p>Now, let’s derive the training objective.</p> \[\text{KL}(\mathcal{N}(\theta \mid \mu, \Sigma) \; \Vert \; p(\theta \mid \mathcal{D})) = \int_{-\infty}^{\infty} \mathcal{N}(\theta \mid \mu, \Sigma) \log(\frac{\mathcal{N}(\theta \mid \mu, \Sigma)}{p(\theta \mid \mathcal{D})}) d\theta\] <p>First, let’s first deal with the denominator of natural logarithm.</p> <p>\(p(\theta \mid \mathcal{D}) = \frac{p(\mathcal{D} \mid \theta) p(\theta)}{p(\mathcal{D})}\) We can consider \(\ln(\frac{1}{p(\mathcal{D})}) = - \ln(p(\mathcal{D}))\) as a constant.</p> \[= \int_{-\infty}^{\infty} \mathcal{N}(\theta | \mu, \Sigma) \log(\frac{\mathcal{N}(\theta | \mu, \Sigma)}{p(\mathcal{D} | \theta) p(\theta)}) + C_1\] <p>Let’s separate the logarithm:</p> \[\begin{split} &amp;= \int_{-\infty}^{\infty} \mathcal{N}(\theta \mid \mu, \Sigma) \log(\frac{\mathcal{N}(\theta \mid \mu, \Sigma)}{p(\theta)}) d\theta - \int_{-\infty}^{\infty} \mathcal{N}(\theta \mid \mu, \Sigma) \log( p(\mathcal{D} \mid \theta)) d\theta + C_1 \\ &amp;= \text{KL}(\mathcal{N}(\theta \mid \mu, \Sigma) \; || \; p(\theta)) - \int_{-\infty}^{\infty} \mathcal{N}(\theta \mid \mu, \Sigma) \log( p(\mathcal{D} \mid \theta)) d\theta + C_1\\ &amp;= \text{KL}(\mathcal{N}(\theta \mid \mu, \Sigma) \; || \; p(\theta)) - \mathbb{E}_{\theta \sim \mathcal{N}(\theta \mid \mu, \Sigma)} \log(p(\mathcal{D} \mid \theta)) + C_1 \end{split}\] <p>Ok so far so good, now assume that the input data is <em>identically independently distributed</em> (each \((Y_i, X_i)\) are independent from each other). We can represent \(p(\mathcal{D} \mid \theta)\) as follows: \(p(\mathcal{D} \mid \theta) = \prod_{i} p(Y_i, X_i \mid \theta)\) When you take the logarithm: \(\ln(p(\mathcal{D} \mid \theta)) = \sum_{i} \ln( p(Y_i, X_i \mid \theta))\)</p> <p>Therefore the expectation reduces to the following:</p> \[\mathbb{E}_{\theta \sim \mathcal{N}(\theta \mid \mu, \Sigma)} \log(p(\mathcal{D}\mid \theta)) = \sum_i \mathbb{E}_{\theta \sim \mathcal{N}} \log( p(Y_i, X_i \mid \theta))\] <p>Let’s play with the probabilities here as well:</p> \[\begin{split}p(Y_i, X_i \mid \theta) &amp;= \frac{p(Y_i, X_i, \theta)}{p(\theta)}\\ &amp;=\frac{p(Y_i \mid X_i, \theta) p(X_i, \theta)}{p(\theta)} \\ &amp;= \frac{p(Y_i \mid X_i, \theta) p(X_i \mid \theta) p(\theta)}{p(\theta)} \\ &amp;= p(Y_i \mid X_i, \theta) p(X_i \mid \theta)\\ &amp;= p(Y_i \mid X_i, \theta) p(X_i)\\ &amp;= p(Y_i \mid X_i, \theta) \; C'\end{split}\] <p>\(\theta\) and \(X_i\) are independent as long as \(Y_i\) is not provided (if not convinced, please have a look at one of our previous observations). Now, insert this result to the previous expectation:</p> \[\begin{split} \sum_i \mathbb{E}_{\theta \sim \mathcal{N}} \log( p(Y_i \mid X_i, \theta) C') &amp;= \sum_i \mathbb{E}_{\theta \sim \mathcal{N}} \log( p(Y_i \mid X_i, \theta)) + \underbrace{ \log(C') \sum_i \mathbb{E}_{\theta \sim \mathcal{N}}[1]}_\textrm{$C_2$} \\ &amp;= \sum_i \mathbb{E}_{\theta \sim \mathcal{N}}\log( p(Y_i \mid X_i, \theta)) + C_2 \end{split}\] <p>Expected value of a constant is equal to that constant.</p> <p>Ok now, there is a method called <strong>Monte Carlo Simulation.</strong> Unnecessarily fancy name, but basically it says the following: To estimate the expected value of a function \(f(\theta)\) under the distribution \(\theta \sim \mathcal{N}\), simply just run the experiment \(K\) times and take the average value of \(f(\theta)\) over runs. We can approximate the last equation as follows with MC simulation:</p> <p>\(\sum_i \mathbb{E}_{\theta \sim \mathcal{N}} \log( p(Y_i \mid X_i, \theta)) = \sum_i \frac{1}{K} \sum_k \log(p(Y_i \mid X_i, \theta_k))\) where \(\theta_k \sim \mathcal{N}(\mu, \Sigma)\)</p> <p>So, the final objective function becomes the following:</p> \[min_{\mu, \Sigma} \; \text{KL}(\mathcal{N}(\theta \mid \mu, \Sigma) \; \Vert \; p(\theta)) - \frac{1}{K} \sum_i \sum_k \log(p(Y_i \mid X_i, \theta_k)) + C\] <p>Right part can be calculated by simply running some experiments. For the left part, what is prior \(p(\theta)\)? This represents our initial idea as to the probability distribution for model parameters. Popular choice for the posterior is just a standard normal distribution: \(p(\theta) = \mathcal{N}(\vec{0}^{\,}, {I})\) (multivariate)</p> <p>Another observation here is that allowing a full covariance matrix \(\Sigma\) can cause the computation to take extremely long (there are lots of possibilities). One trick is restricting the covariance matrix to be diagonal (independent features) \(\rightarrow \Sigma = \text{diag}(\sigma^2)\) where \(\sigma^2\) is the variance vector for each feature \((\text{Var}[\theta^i])\)*.</p> <p>* \(\theta_i\) denotes the \(i^{\text{th}}\) set of parameters sampled from the Gaussian distribution. \(\theta^i\) denotes the \(i^{\text{th}}\) dimension of the vector of parameters.</p> \[\text{KL}(\mathcal{N}(\theta \mid \mu, \text{diag}(\sigma^2)) \; \Vert \; \mathcal{N}(\vec{0}^{\,}, {I})) = \int_{-\infty}^{\infty} \mathcal{N}(\theta \mid \mu, \text{diag}(\sigma^2))\log \left(\frac{\mathcal{N}(\theta \mid \mu, \text{diag}(\sigma^2))}{\mathcal{N}(\vec{0}^{\,}, {I})} \right) d\theta \\\] <p>So, this equation boils down to the following:</p> <p>\(= \sum_i [\frac{\mu_i^2}{\sigma_i^2} + \log\sigma_i - \frac{1}{2}]\) ⇒ this behaves like a regularizer for \(\mu\) and \(\sigma\)</p> <p>Multivariate Gaussian distribution for \(k\) features (\(k\) dimensional \(\theta\) vector):</p> \[\mathcal{N}(\mu, \Sigma) = (2\pi)^{-k/2} \text{det}(\Sigma)^{-1/2} \text{exp}(-\frac{1}{2} (x-\mu)^T \Sigma^{-1}(x - \mu))\] <p>for \(\mathcal{N}(\vec{0}^{\,}, {I}) = (2\pi)^{-k/2} \text{exp}(-\frac{1}{2}x^Tx)\)</p> <p>Then the final optimization problem becomes:</p> <p>\(min_{\mu, \Sigma} \; \sum_i [\frac{\mu_i^2}{\sigma_i^2} + \log\sigma_i - \frac{1}{2}] - \frac{1}{K} \sum_i \sum_k \log(p(Y_i \mid X_i, \theta_k)) + C\) where \(\theta_k \sim \mathcal{N}(\mu, \text{diag}(\sigma^2))\)</p> <p>Now, our equations are still not Neural Network friendly - because we have to try to minimize a function that is not directly dependent on \(\mu\) and \(\Sigma\). We have to represent \(\theta\) to include both \(\mu\) and \(\Sigma\). We can use the reparameterization here.</p> <p>If \(X \sim \mathcal{N}(\mu, \sigma^2)\), then \(Z = \frac{X - \mu}{\sigma} \sim \mathcal{N}(0, 1)\) Since we set \(\Sigma\) to be \(\text{diag}(\sigma^2)\), all dimensions of the parameter vector \(\theta\) are independent of each other. Individually \(\theta^i \sim \mathcal{N}(\mu_i, \sigma_i^2)\) - 1D Gaussian random variable. Therefore we can perform the given parameterization trick. By the help of reparameterization, we can separate the randomness and backpropagation - this way we avoid differentiating with respect to sampling (a similar problem occurs in Stochastic Variational Inference - which is solved via either score gradient estimators or reparameterization trick).</p> <p>\(\theta = \mu + \sigma \odot \epsilon\) where \(\odot\) is the pointwise multiplication and \(\epsilon \sim \mathcal{N}(\vec{0}^{\,}, {I})\)</p> <p>This reparameterization makes the backpropagation extremely simple:</p> \[\frac{\partial \mathcal{L}}{\partial \mu_i} = \sum_j \frac{\partial \mathcal{L}}{\partial \theta_j} \frac{\partial \theta_j}{\partial \mu_i} = \frac{\partial \mathcal{L}}{\partial \theta_i}\] \[\frac{\partial \mathcal{L}}{\partial \sigma_i} = \sum_j \frac{\partial \mathcal{L}}{\partial \theta_j} \frac{\partial \theta_j}{\partial \sigma_i} = \epsilon_i \frac{\partial \mathcal{L}}{\partial \theta_i}\] <p>Usually we set \(K\) to \(1\), that is, we only sample one \(\theta\) from the distribution <strong>in each iteration</strong>. Then the second term simply becomes the cross-entropy loss:</p> <p>\(\sum_i \log(p(Y_i \mid X_i, \theta))\) is the total loss using Cross Entropy. There is one single addition we have to do: Averaging</p> <p>\(\frac{1}{N} \sum_i \log(p(Y_i \mid X_i, \theta))\) calculates the cross entropy loss (\(P(Y_i) = 1\)) for a batch of \((Y_i, X_i)\) pairs.</p> <p>One final note: Standard deviation \(\sigma\) is the square root of variance \(\sigma^2\) and therefore it must be non-negative. However, PyTorch doesn’t know this and it might produce negative \(\sigma\) as a result of the backpropagation. We can define another function for \(\sigma\) with an input allowed to be negative:</p> <p>\(\sigma = \ln(1+e^\rho)\) (softplus - \(\sigma\) is always non-negative, let the model update the value of \(\rho\))</p> <p>PyTorch code for “Training Infinite Number of Models” (\(K\) is set to \(1\), therefore only one \(\epsilon\) is created):</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BayesBackpropLinear</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">in_dim</span><span class="p">,</span> <span class="n">out_dim</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">BayesBackpropLinear</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">in_dim</span><span class="p">,</span> <span class="n">out_dim</span><span class="p">).</span><span class="nf">uniform_</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">in_dim</span><span class="p">,</span> <span class="n">out_dim</span><span class="p">).</span><span class="nf">uniform_</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">mu</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">softplus</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">mu</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">eps</span>
        <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">mm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_loss</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">logits</span><span class="p">,</span> <span class="n">targets</span><span class="p">):</span>
        <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">cross_entropy</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="sh">"</span><span class="s">mean</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">softplus</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">kl_prior</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">mu</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">torch</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">log_likelihood</span> <span class="o">+</span> <span class="n">kl_prior</span>
</code></pre></div></div> <p>In the forward function, we multiply \(\theta\) with \(x\). Here the idea is to mimic a shallow NN consisting of input and output layers. Result of the multiplication gives us the logits (activation must be applied to get the predicted probabilities) The main idea here is this: Rather than training one parameter set \(\theta\) over each iteration, we train parameters \(\mu\) and \(\sigma\) that will generate infinitely many \(\theta\) → Bayes ML In the forward function, we multiply \(\theta\) with \(x\). Here the idea is to mimic a shallow NN consisting of input and output layers. Result of the multiplication gives us the logits (activation must be applied to get the predicted probabilities) The main idea in this code is this: Rather than training one parameter set \(\theta\) over each iteration, we train parameters \(\mu\) and \(\sigma\) that will generate infinitely many \(\theta\) → Bayes ML.</p> <p>As a result of this model, we will get \(\mu^*\) and \(\Sigma^*\) that minimizes the \(\text{KL}(\mathcal{N}(\theta \mid \mu(\mathcal{D}), \Sigma(\mathcal{D})), p(\theta \mid \mathcal{D}))\) where \(P(\theta \mid \mathcal{D}) \sim \mathcal{N}(\theta \mid \mu^*(\mathcal{D}), \Sigma^*(\mathcal{D}))\)</p> <p>What remains is the application of BMA. Calculate the expected value of \(P(y \mid x, \theta)\) using the \(\theta\) sampled from \(\mathcal{N}(\theta \mid \mu^*(\mathcal{D}), \Sigma^*(\mathcal{D}))\) using the learned mean and variance.</p> \[P(y | x, \mathcal{D}) = \int{P(y | x, \theta) \; P(\theta | \mathcal{D}) \; d\theta} = \mathbb{E}_{P(\theta|D)} P(y |x, \theta)\] <h2 id="bayesian-ml-approach-3-dropout">Bayesian ML Approach #3: Dropout</h2> <p>On the spectrum of Bayesian methods, dropout is between the sum of Diracs (training a few deterministic ML models) and the variational approach (that trains an infinite number of models).</p> <p>Dropout is randomly applied to the model <strong>for each iteration.</strong> Considering the Cross Entropy Loss, objective function of the model can be formulated as follows:</p> <p>\(-\frac{1}{N}\sum_{n=1}^{N}\log P(y_n \mid x_n, s \odot \theta)\) where we turn on/off each weight dimension randomly in each iteration: \(s_i \sim \text{Bernouilli}( p)\) where \(p\) is the dropout rate. Dropout is something that people used to use a lot → Bayesian NN for free.</p> <p>Now, here is the idea: Normally, we train models with dropouts and then close the dropout at inference time (test time). Here, we can still apply dropout to have different models make predictions during test time. Again, we apply Bayesian Model Averaging with Monte Carlo estimation for the integral.</p> \[\begin{split}P(y \mid x, \mathcal{D}) &amp;= \int{P(y \mid x, \theta) \; P(\theta \mid \mathcal{D}) \; d\theta} \\ &amp;= \mathbb{E}_{\theta \sim P(\theta \mid D)} P(y \mid x, \theta) \\ &amp;\approx \frac{1}{K} \sum_{k=1}^K P(y \mid x, \theta_{k}) \;\; \text{where} \;\; \theta_{k} = s_k \odot \theta \end{split}\] <p>There are \(K\) models to compare with each other. We expect to have disagreements between the models for OOD samples, and therefore measure the epistemic uncertainty.</p> <p>Problem: Unfortunately, this method doesn’t work that well in practice as shown in the paper <a href="https://arxiv.org/abs/1612.01474" target="_blank" rel="noopener noreferrer">Simple and Scalable Predictive Uncertainty Estimation using Deep Ensembles</a>.</p> <center> <figure> <picture> <img src="/assets/posts/post1/bayesian-6.png" class="img-fluid rounded z-depth-1" width="400" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption">R: Random signed vector added - AT: Adversarial training added</figcaption> </figure> </center> <h2 id="bayesian-ml-approach-4-training-a-curve-of-an-infinite-number-of-models">Bayesian ML Approach #4: Training a Curve of an Infinite Number of Models</h2> <p>This idea makes the following assumption: If you train two models independently, you get two different \(\theta_i\) weights that are far away from each other in the space. But from one to another, there is a path where the loss value is always low. So we can find the weights in between to have infinite number of models.</p> <p>This is also Bayesian, as we are training an infinite number of models according to a learned parametric approximate posterior.</p> <p>Here is the algorithm to train a curve of infinite number of models:</p> <ol> <li>Train two independent models: \(\theta_1\) and \(\theta_2\)</li> <li>Parameterize the curve via a third model \(\phi\). There are two line segments between the models.</li> </ol> \[\theta_{\phi}(t) = \begin{cases} 2(t\phi + (0.5-t)\theta_1)\;\;\;\;\;\;\;\;\;\;\;\;\;\text{if}\; t \in [0, 0.5) \\ 2((t - 0.5)\theta_2 + (1-t)\phi) \;\;\;\; \text{if} \; t \in [0.5, 1] \end{cases}\] <p>\(\theta_1\) and \(\theta_2\) are already known, we just have to find \(\phi\) so that the any model on the curve has low training loss. So, we actually have to minimize the expected value of the cross entropy loss:</p> <p>\(\text{min}_\phi \;\mathbb{E}_{\theta \sim q_{\phi}(\theta)} \left[ -\frac{1}{N} \sum_n \log P(y_n \mid x_n, \theta) \right]\) → find a suitable \(\phi\) under the expectation of both \(\theta\) and \(X, Y\)</p> <p>Using the reparameterization trick:</p> \[\text{min}_\phi \;\mathbb{E}_{t \sim \text{Unif}[0, 1]}\left[ -\frac{1}{N} \sum_n \log P(y_n | x_n, \theta_{\phi}(t)) \right]\] <p>This minimization aims to minimize the cross entropy loss by finding a suitable \(\phi\).</p> <blockquote> <p>A general observation (<a href="https://arxiv.org/pdf/1802.10026.pdf" target="_blank" rel="noopener noreferrer">Loss Surfaces, Mode Connectivity, and Fast Ensembling of DNNs</a>) is that almost all pairs of independently trained models (\(\theta_1, \theta_2\)) for DNNs are connected through a third point \(\phi\) in a low-loss “highway” that we can easily find. This gives an interesting intuition for the loss landscape: Most solutions in the DL landscape are connected by some piecewise linear curve. This is not so surprising: We have millions/billions of dimensions to choose from. We can likely find a 2D cut of the loss in which there exists a parametric curve parameterized by \(\phi\) that connects the two endpoints with a low training loss.</p> </blockquote> <p>After training the model and finding a suitable \(\phi\), the rest is using the <strong>Bayesian Model Averaging</strong> by sampling models (weights) from the curve between \(\theta_1\) and \(\theta_2\):</p> \[\begin{split} P(y \mid x, \mathcal{D}) &amp;= \int{P(y \mid x, \theta) \; P(\theta \mid \mathcal{D}) \; d\theta} \\ &amp;= \mathbb{E}_{\theta \sim P(\theta|D)} P(y \mid x, \theta) \\ &amp;\approx \frac{1}{K} \sum_{k=1}^K P(y | x, \theta_\phi{(t^{(k)})}) \;\; \text{where} \;\; t^{(k)} \sim \text{Unif}[0, 1] \end{split}\] <h2 id="bayesian-ml-approach-5-stochastic-weight-averaging-swag">Bayesian ML Approach #5: Stochastic Weight Averaging (SWAG)</h2> <p>Lastly, we can exploit the randomness in SGD as a cheap source for Bayesian ML. Because of small batches (usually batch size = 1), SGD trajectory is very noisy. The training’s final few iterations (epochs) can be treated as samples from the approximate posterior distribution \(p(\theta \mid \mathcal{D})\).</p> <p>We would like to approximate the last iterations with Gaussian:</p> \[p(\theta | \mathcal{D}) \sim \mathcal{N}(\theta | \mu(\mathcal{D}), \Sigma(\mathcal{D}))\] <p>We assume that last \(\theta_i\) values are coming from a Gaussian distribution. We want to find the mean and the covariance matrix for it. We can use the sample estimates basically:</p> \[\mu = \frac{1}{L} \sum_l \theta_l\] <p>\(\Sigma = \text{diag} \left( \frac{1}{L} \sum_l \theta_l^2 - (\frac{1}{L} \sum_l \theta_l)^2 \right)\) assuming that the different features \(\theta_i\) and \(\theta_j \; (i \neq j)\) are not correlated with each other.</p> <p>SWAG is not so scalable because it requires the full empirical covariance matrix. On the other hand SWAG-Diag can be used to reduce the time complexity. However, according to the benchmark results, it seems that SWAG-Diag only scales better computationally, but the results do not follow.</p> <p>After getting the \(p(\theta \mid \mathcal{D})\), rest is similar to what we have done so far:</p> <ol> <li> <p>Using the posterior, get the prediction using <strong>Bayesian Model Averaging</strong>. Basically, we are calculating the expected value of the prediction based on the distribution \(\theta \sim p(\theta \mid \mathcal{D})\).</p> \[P(y | x, \mathcal{D}) = \int{P(y | x, \theta) \; P(\theta | \mathcal{D}) \; d\theta} = \mathbb{E}_{\theta \sim P(\theta|\mathcal{D})} P(y |x, \theta)\] </li> <li> <p>To approximate the epistemic uncertainty, either calculate the entropy \(\mathbb{H}(P(y \mid x, \mathcal{D}))\) or the max-prob for classification \(\text{max}_k P(Y = k \mid x, \mathcal{D})\).</p> </li> </ol> <hr> <p><strong>Conclusion</strong>: There are strong assumptions for these Bayesian approaches to work:</p> <ul> <li>We should have a reasonable prior for the parameters \(\theta\).</li> <li>The posterior follows the assumed distribution (e.g., a Gaussian). Of course, the posterior will seldom be truly Gaussian. This is a huge assumption.</li> </ul> <hr> <p><strong>References:</strong> Bálint Mucsányi, Michael Kirchhof, Elisa Nguyen, Alexander Rubinstein, Seong Joon Oh (2023): “Proper/Strictly Proper Scoring Rule”; in: Trustworthy Machine Learning; URL: https://trustworthyml.io/; DOI: 10.48550/arXiv.2310.08215.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Karahan Sarıtaş. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.2/dist/umd/popper.min.js" integrity="sha256-l/1pMF/+J4TThfgARS6KwWrk/egwuVvhRzfLAMQ6Ds4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" integrity="sha256-SyTu6CwrfOhaznYZPoolVw2rxoY7lKYKQvqbtqN93HI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script src="/assets/js/zoom.js"></script> <script src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> </body> </html>